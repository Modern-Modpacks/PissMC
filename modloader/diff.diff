diff -Nru decomped/com/mojang/rubydung/HitResult.java src/main/java/com/mojang/rubydung/HitResult.java
--- decomped/com/mojang/rubydung/HitResult.java	1970-01-01 03:00:00.000000000 +0300
+++ src/main/java/com/mojang/rubydung/HitResult.java	2023-09-22 22:15:51.370027787 +0300
@@ -0,0 +1,21 @@
+package com.mojang.rubydung;
+
+public class HitResult {
+  public int x;
+  
+  public int y;
+  
+  public int z;
+  
+  public int o;
+  
+  public int f;
+  
+  public HitResult(int x, int y, int z, int o, int f) {
+    this.x = x;
+    this.y = y;
+    this.z = z;
+    this.o = o;
+    this.f = f;
+  }
+}
diff -Nru decomped/com/mojang/rubydung/level/Chunk.java src/main/java/com/mojang/rubydung/level/Chunk.java
--- decomped/com/mojang/rubydung/level/Chunk.java	1970-01-01 03:00:00.000000000 +0300
+++ src/main/java/com/mojang/rubydung/level/Chunk.java	2023-09-22 22:15:51.394027759 +0300
@@ -0,0 +1,90 @@
+package com.mojang.rubydung.level;
+
+import com.mojang.rubydung.Textures;
+import com.mojang.rubydung.phys.AABB;
+import org.lwjgl.opengl.GL11;
+
+public class Chunk {
+  public AABB aabb;
+  
+  public final Level level;
+  
+  public final int x0;
+  
+  public final int y0;
+  
+  public final int z0;
+  
+  public final int x1;
+  
+  public final int y1;
+  
+  public final int z1;
+  
+  private boolean dirty = true;
+  
+  private int lists = -1;
+  
+  private static int texture = Textures.loadTexture("/terrain.png", 9728);
+  
+  private static Tesselator t = new Tesselator();
+  
+  public static int rebuiltThisFrame = 0;
+  
+  public static int updates = 0;
+  
+  public Chunk(Level level, int x0, int y0, int z0, int x1, int y1, int z1) {
+    this.level = level;
+    this.x0 = x0;
+    this.y0 = y0;
+    this.z0 = z0;
+    this.x1 = x1;
+    this.y1 = y1;
+    this.z1 = z1;
+    this.aabb = new AABB(x0, y0, z0, x1, y1, z1);
+    this.lists = GL11.glGenLists(2);
+  }
+  
+  private void rebuild(int layer) {
+    if (rebuiltThisFrame == 2)
+      return; 
+    this.dirty = false;
+    updates++;
+    rebuiltThisFrame++;
+    GL11.glNewList(this.lists + layer, 4864);
+    GL11.glEnable(3553);
+    GL11.glBindTexture(3553, texture);
+    t.init();
+    int tiles = 0;
+    for (int x = this.x0; x < this.x1; x++) {
+      for (int y = this.y0; y < this.y1; y++) {
+        for (int z = this.z0; z < this.z1; z++) {
+          if (this.level.isTile(x, y, z)) {
+            int tex = (y == this.level.depth * 2 / 3) ? 0 : 1;
+            tiles++;
+            if (tex == 0) {
+              Tile.rock.render(t, this.level, layer, x, y, z);
+            } else {
+              Tile.grass.render(t, this.level, layer, x, y, z);
+            } 
+          } 
+        } 
+      } 
+    } 
+    t.flush();
+    GL11.glDisable(3553);
+    GL11.glEndList();
+  }
+  
+  public void render(int layer) {
+    if (this.dirty) {
+      rebuild(0);
+      rebuild(1);
+    } 
+    GL11.glCallList(this.lists + layer);
+  }
+  
+  public void setDirty() {
+    this.dirty = true;
+  }
+}
diff -Nru decomped/com/mojang/rubydung/level/Frustum.java src/main/java/com/mojang/rubydung/level/Frustum.java
--- decomped/com/mojang/rubydung/level/Frustum.java	1970-01-01 03:00:00.000000000 +0300
+++ src/main/java/com/mojang/rubydung/level/Frustum.java	2023-09-22 22:15:51.382027773 +0300
@@ -0,0 +1,184 @@
+package com.mojang.rubydung.level;
+
+import com.mojang.rubydung.phys.AABB;
+import java.nio.FloatBuffer;
+import org.lwjgl.BufferUtils;
+import org.lwjgl.opengl.GL11;
+
+public class Frustum {
+  public float[][] m_Frustum = new float[6][4];
+  
+  public static final int RIGHT = 0;
+  
+  public static final int LEFT = 1;
+  
+  public static final int BOTTOM = 2;
+  
+  public static final int TOP = 3;
+  
+  public static final int BACK = 4;
+  
+  public static final int FRONT = 5;
+  
+  public static final int A = 0;
+  
+  public static final int B = 1;
+  
+  public static final int C = 2;
+  
+  public static final int D = 3;
+  
+  private static Frustum frustum = new Frustum();
+  
+  private FloatBuffer _proj;
+  
+  private FloatBuffer _modl;
+  
+  private FloatBuffer _clip;
+  
+  float[] proj;
+  
+  float[] modl;
+  
+  float[] clip;
+  
+  public static Frustum getFrustum() {
+    frustum.calculateFrustum();
+    return frustum;
+  }
+  
+  private void normalizePlane(float[][] frustum, int side) {
+    float magnitude = (float)Math.sqrt((frustum[side][0] * frustum[side][0] + frustum[side][1] * frustum[side][1] + frustum[side][2] * frustum[side][2]));
+    frustum[side][0] = frustum[side][0] / magnitude;
+    frustum[side][1] = frustum[side][1] / magnitude;
+    frustum[side][2] = frustum[side][2] / magnitude;
+    frustum[side][3] = frustum[side][3] / magnitude;
+  }
+  
+  private Frustum() {
+    this._proj = BufferUtils.createFloatBuffer(16);
+    this._modl = BufferUtils.createFloatBuffer(16);
+    this._clip = BufferUtils.createFloatBuffer(16);
+    this.proj = new float[16];
+    this.modl = new float[16];
+    this.clip = new float[16];
+  }
+  
+  private void calculateFrustum() {
+    this._proj.clear();
+    this._modl.clear();
+    this._clip.clear();
+    GL11.glGetFloat(2983, this._proj);
+    GL11.glGetFloat(2982, this._modl);
+    this._proj.flip().limit(16);
+    this._proj.get(this.proj);
+    this._modl.flip().limit(16);
+    this._modl.get(this.modl);
+    this.clip[0] = this.modl[0] * this.proj[0] + this.modl[1] * this.proj[4] + this.modl[2] * this.proj[8] + this.modl[3] * this.proj[12];
+    this.clip[1] = this.modl[0] * this.proj[1] + this.modl[1] * this.proj[5] + this.modl[2] * this.proj[9] + this.modl[3] * this.proj[13];
+    this.clip[2] = this.modl[0] * this.proj[2] + this.modl[1] * this.proj[6] + this.modl[2] * this.proj[10] + this.modl[3] * this.proj[14];
+    this.clip[3] = this.modl[0] * this.proj[3] + this.modl[1] * this.proj[7] + this.modl[2] * this.proj[11] + this.modl[3] * this.proj[15];
+    this.clip[4] = this.modl[4] * this.proj[0] + this.modl[5] * this.proj[4] + this.modl[6] * this.proj[8] + this.modl[7] * this.proj[12];
+    this.clip[5] = this.modl[4] * this.proj[1] + this.modl[5] * this.proj[5] + this.modl[6] * this.proj[9] + this.modl[7] * this.proj[13];
+    this.clip[6] = this.modl[4] * this.proj[2] + this.modl[5] * this.proj[6] + this.modl[6] * this.proj[10] + this.modl[7] * this.proj[14];
+    this.clip[7] = this.modl[4] * this.proj[3] + this.modl[5] * this.proj[7] + this.modl[6] * this.proj[11] + this.modl[7] * this.proj[15];
+    this.clip[8] = this.modl[8] * this.proj[0] + this.modl[9] * this.proj[4] + this.modl[10] * this.proj[8] + this.modl[11] * this.proj[12];
+    this.clip[9] = this.modl[8] * this.proj[1] + this.modl[9] * this.proj[5] + this.modl[10] * this.proj[9] + this.modl[11] * this.proj[13];
+    this.clip[10] = this.modl[8] * this.proj[2] + this.modl[9] * this.proj[6] + this.modl[10] * this.proj[10] + this.modl[11] * this.proj[14];
+    this.clip[11] = this.modl[8] * this.proj[3] + this.modl[9] * this.proj[7] + this.modl[10] * this.proj[11] + this.modl[11] * this.proj[15];
+    this.clip[12] = this.modl[12] * this.proj[0] + this.modl[13] * this.proj[4] + this.modl[14] * this.proj[8] + this.modl[15] * this.proj[12];
+    this.clip[13] = this.modl[12] * this.proj[1] + this.modl[13] * this.proj[5] + this.modl[14] * this.proj[9] + this.modl[15] * this.proj[13];
+    this.clip[14] = this.modl[12] * this.proj[2] + this.modl[13] * this.proj[6] + this.modl[14] * this.proj[10] + this.modl[15] * this.proj[14];
+    this.clip[15] = this.modl[12] * this.proj[3] + this.modl[13] * this.proj[7] + this.modl[14] * this.proj[11] + this.modl[15] * this.proj[15];
+    this.m_Frustum[0][0] = this.clip[3] - this.clip[0];
+    this.m_Frustum[0][1] = this.clip[7] - this.clip[4];
+    this.m_Frustum[0][2] = this.clip[11] - this.clip[8];
+    this.m_Frustum[0][3] = this.clip[15] - this.clip[12];
+    normalizePlane(this.m_Frustum, 0);
+    this.m_Frustum[1][0] = this.clip[3] + this.clip[0];
+    this.m_Frustum[1][1] = this.clip[7] + this.clip[4];
+    this.m_Frustum[1][2] = this.clip[11] + this.clip[8];
+    this.m_Frustum[1][3] = this.clip[15] + this.clip[12];
+    normalizePlane(this.m_Frustum, 1);
+    this.m_Frustum[2][0] = this.clip[3] + this.clip[1];
+    this.m_Frustum[2][1] = this.clip[7] + this.clip[5];
+    this.m_Frustum[2][2] = this.clip[11] + this.clip[9];
+    this.m_Frustum[2][3] = this.clip[15] + this.clip[13];
+    normalizePlane(this.m_Frustum, 2);
+    this.m_Frustum[3][0] = this.clip[3] - this.clip[1];
+    this.m_Frustum[3][1] = this.clip[7] - this.clip[5];
+    this.m_Frustum[3][2] = this.clip[11] - this.clip[9];
+    this.m_Frustum[3][3] = this.clip[15] - this.clip[13];
+    normalizePlane(this.m_Frustum, 3);
+    this.m_Frustum[4][0] = this.clip[3] - this.clip[2];
+    this.m_Frustum[4][1] = this.clip[7] - this.clip[6];
+    this.m_Frustum[4][2] = this.clip[11] - this.clip[10];
+    this.m_Frustum[4][3] = this.clip[15] - this.clip[14];
+    normalizePlane(this.m_Frustum, 4);
+    this.m_Frustum[5][0] = this.clip[3] + this.clip[2];
+    this.m_Frustum[5][1] = this.clip[7] + this.clip[6];
+    this.m_Frustum[5][2] = this.clip[11] + this.clip[10];
+    this.m_Frustum[5][3] = this.clip[15] + this.clip[14];
+    normalizePlane(this.m_Frustum, 5);
+  }
+  
+  public boolean pointInFrustum(float x, float y, float z) {
+    for (int i = 0; i < 6; i++) {
+      if (this.m_Frustum[i][0] * x + this.m_Frustum[i][1] * y + this.m_Frustum[i][2] * z + this.m_Frustum[i][3] <= 0.0F)
+        return false; 
+    } 
+    return true;
+  }
+  
+  public boolean sphereInFrustum(float x, float y, float z, float radius) {
+    for (int i = 0; i < 6; i++) {
+      if (this.m_Frustum[i][0] * x + this.m_Frustum[i][1] * y + this.m_Frustum[i][2] * z + this.m_Frustum[i][3] <= -radius)
+        return false; 
+    } 
+    return true;
+  }
+  
+  public boolean cubeFullyInFrustum(float x1, float y1, float z1, float x2, float y2, float z2) {
+    for (int i = 0; i < 6; i++) {
+      if (this.m_Frustum[i][0] * x1 + this.m_Frustum[i][1] * y1 + this.m_Frustum[i][2] * z1 + this.m_Frustum[i][3] <= 0.0F)
+        return false; 
+      if (this.m_Frustum[i][0] * x2 + this.m_Frustum[i][1] * y1 + this.m_Frustum[i][2] * z1 + this.m_Frustum[i][3] <= 0.0F)
+        return false; 
+      if (this.m_Frustum[i][0] * x1 + this.m_Frustum[i][1] * y2 + this.m_Frustum[i][2] * z1 + this.m_Frustum[i][3] <= 0.0F)
+        return false; 
+      if (this.m_Frustum[i][0] * x2 + this.m_Frustum[i][1] * y2 + this.m_Frustum[i][2] * z1 + this.m_Frustum[i][3] <= 0.0F)
+        return false; 
+      if (this.m_Frustum[i][0] * x1 + this.m_Frustum[i][1] * y1 + this.m_Frustum[i][2] * z2 + this.m_Frustum[i][3] <= 0.0F)
+        return false; 
+      if (this.m_Frustum[i][0] * x2 + this.m_Frustum[i][1] * y1 + this.m_Frustum[i][2] * z2 + this.m_Frustum[i][3] <= 0.0F)
+        return false; 
+      if (this.m_Frustum[i][0] * x1 + this.m_Frustum[i][1] * y2 + this.m_Frustum[i][2] * z2 + this.m_Frustum[i][3] <= 0.0F)
+        return false; 
+      if (this.m_Frustum[i][0] * x2 + this.m_Frustum[i][1] * y2 + this.m_Frustum[i][2] * z2 + this.m_Frustum[i][3] <= 0.0F)
+        return false; 
+    } 
+    return true;
+  }
+  
+  public boolean cubeInFrustum(float x1, float y1, float z1, float x2, float y2, float z2) {
+    for (int i = 0; i < 6; ) {
+      if (this.m_Frustum[i][0] * x1 + this.m_Frustum[i][1] * y1 + this.m_Frustum[i][2] * z1 + this.m_Frustum[i][3] > 0.0F || 
+        this.m_Frustum[i][0] * x2 + this.m_Frustum[i][1] * y1 + this.m_Frustum[i][2] * z1 + this.m_Frustum[i][3] > 0.0F || 
+        this.m_Frustum[i][0] * x1 + this.m_Frustum[i][1] * y2 + this.m_Frustum[i][2] * z1 + this.m_Frustum[i][3] > 0.0F || 
+        this.m_Frustum[i][0] * x2 + this.m_Frustum[i][1] * y2 + this.m_Frustum[i][2] * z1 + this.m_Frustum[i][3] > 0.0F || 
+        this.m_Frustum[i][0] * x1 + this.m_Frustum[i][1] * y1 + this.m_Frustum[i][2] * z2 + this.m_Frustum[i][3] > 0.0F || 
+        this.m_Frustum[i][0] * x2 + this.m_Frustum[i][1] * y1 + this.m_Frustum[i][2] * z2 + this.m_Frustum[i][3] > 0.0F || 
+        this.m_Frustum[i][0] * x1 + this.m_Frustum[i][1] * y2 + this.m_Frustum[i][2] * z2 + this.m_Frustum[i][3] > 0.0F || 
+        this.m_Frustum[i][0] * x2 + this.m_Frustum[i][1] * y2 + this.m_Frustum[i][2] * z2 + this.m_Frustum[i][3] > 0.0F) {
+        i++;
+        continue;
+      } 
+      return false;
+    } 
+    return true;
+  }
+  
+  public boolean cubeInFrustum(AABB aabb) {
+    return cubeInFrustum(aabb.x0, aabb.y0, aabb.z0, aabb.x1, aabb.y1, aabb.z1);
+  }
+}
diff -Nru decomped/com/mojang/rubydung/level/Level.java src/main/java/com/mojang/rubydung/level/Level.java
--- decomped/com/mojang/rubydung/level/Level.java	1970-01-01 03:00:00.000000000 +0300
+++ src/main/java/com/mojang/rubydung/level/Level.java	2023-09-22 22:15:51.382027773 +0300
@@ -0,0 +1,156 @@
+package com.mojang.rubydung.level;
+
+import com.mojang.rubydung.phys.AABB;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.util.ArrayList;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.GZIPOutputStream;
+
+public class Level {
+  public final int width;
+  
+  public final int height;
+  
+  public final int depth;
+  
+  private byte[] blocks;
+  
+  private int[] lightDepths;
+  
+  private ArrayList<LevelListener> levelListeners = new ArrayList<LevelListener>();
+  
+  public Level(int w, int h, int d) {
+    this.width = w;
+    this.height = h;
+    this.depth = d;
+    this.blocks = new byte[w * h * d];
+    this.lightDepths = new int[w * h];
+    for (int x = 0; x < w; x++) {
+      for (int y = 0; y < d; y++) {
+        for (int z = 0; z < h; z++) {
+          int i = (y * this.height + z) * this.width + x;
+          this.blocks[i] = (byte)((y <= d * 2 / 3) ? 1 : 0);
+        } 
+      } 
+    } 
+    calcLightDepths(0, 0, w, h);
+    load();
+  }
+  
+  public void load() {
+    try {
+      DataInputStream dis = new DataInputStream(new GZIPInputStream(new FileInputStream(new File("level.dat"))));
+      dis.readFully(this.blocks);
+      calcLightDepths(0, 0, this.width, this.height);
+      for (int i = 0; i < this.levelListeners.size(); i++)
+        ((LevelListener)this.levelListeners.get(i)).allChanged(); 
+      dis.close();
+    } catch (Exception e) {
+      e.printStackTrace();
+    } 
+  }
+  
+  public void save() {
+    try {
+      DataOutputStream dos = new DataOutputStream(new GZIPOutputStream(new FileOutputStream(new File("level.dat"))));
+      dos.write(this.blocks);
+      dos.close();
+    } catch (Exception e) {
+      e.printStackTrace();
+    } 
+  }
+  
+  public void calcLightDepths(int x0, int y0, int x1, int y1) {
+    for (int x = x0; x < x0 + x1; x++) {
+      for (int z = y0; z < y0 + y1; z++) {
+        int oldDepth = this.lightDepths[x + z * this.width];
+        int y = this.depth - 1;
+        while (y > 0 && !isLightBlocker(x, y, z))
+          y--; 
+        this.lightDepths[x + z * this.width] = y;
+        if (oldDepth != y) {
+          int yl0 = (oldDepth < y) ? oldDepth : y;
+          int yl1 = (oldDepth > y) ? oldDepth : y;
+          for (int i = 0; i < this.levelListeners.size(); i++)
+            ((LevelListener)this.levelListeners.get(i)).lightColumnChanged(x, z, yl0, yl1); 
+        } 
+      } 
+    } 
+  }
+  
+  public void addListener(LevelListener levelListener) {
+    this.levelListeners.add(levelListener);
+  }
+  
+  public void removeListener(LevelListener levelListener) {
+    this.levelListeners.remove(levelListener);
+  }
+  
+  public boolean isTile(int x, int y, int z) {
+    if (x < 0 || y < 0 || z < 0 || x >= this.width || y >= this.depth || z >= this.height)
+      return false; 
+    return (this.blocks[(y * this.height + z) * this.width + x] == 1);
+  }
+  
+  public boolean isSolidTile(int x, int y, int z) {
+    return isTile(x, y, z);
+  }
+  
+  public boolean isLightBlocker(int x, int y, int z) {
+    return isSolidTile(x, y, z);
+  }
+  
+  public ArrayList<AABB> getCubes(AABB aABB) {
+    ArrayList<AABB> aABBs = new ArrayList<AABB>();
+    int x0 = (int)aABB.x0;
+    int x1 = (int)(aABB.x1 + 1.0F);
+    int y0 = (int)aABB.y0;
+    int y1 = (int)(aABB.y1 + 1.0F);
+    int z0 = (int)aABB.z0;
+    int z1 = (int)(aABB.z1 + 1.0F);
+    if (x0 < 0)
+      x0 = 0; 
+    if (y0 < 0)
+      y0 = 0; 
+    if (z0 < 0)
+      z0 = 0; 
+    if (x1 > this.width)
+      x1 = this.width; 
+    if (y1 > this.depth)
+      y1 = this.depth; 
+    if (z1 > this.height)
+      z1 = this.height; 
+    for (int x = x0; x < x1; x++) {
+      for (int y = y0; y < y1; y++) {
+        for (int z = z0; z < z1; z++) {
+          if (isSolidTile(x, y, z))
+            aABBs.add(new AABB(x, y, z, (x + 1), (y + 1), (z + 1))); 
+        } 
+      } 
+    } 
+    return aABBs;
+  }
+  
+  public float getBrightness(int x, int y, int z) {
+    float dark = 0.8F;
+    float light = 1.0F;
+    if (x < 0 || y < 0 || z < 0 || x >= this.width || y >= this.depth || z >= this.height)
+      return light; 
+    if (y < this.lightDepths[x + z * this.width])
+      return dark; 
+    return light;
+  }
+  
+  public void setTile(int x, int y, int z, int type) {
+    if (x < 0 || y < 0 || z < 0 || x >= this.width || y >= this.depth || z >= this.height)
+      return; 
+    this.blocks[(y * this.height + z) * this.width + x] = (byte)type;
+    calcLightDepths(x, z, 1, 1);
+    for (int i = 0; i < this.levelListeners.size(); i++)
+      ((LevelListener)this.levelListeners.get(i)).tileChanged(x, y, z); 
+  }
+}
diff -Nru decomped/com/mojang/rubydung/level/LevelListener.java src/main/java/com/mojang/rubydung/level/LevelListener.java
--- decomped/com/mojang/rubydung/level/LevelListener.java	1970-01-01 03:00:00.000000000 +0300
+++ src/main/java/com/mojang/rubydung/level/LevelListener.java	2023-09-22 22:15:51.374027783 +0300
@@ -0,0 +1,9 @@
+package com.mojang.rubydung.level;
+
+public interface LevelListener {
+  void tileChanged(int paramInt1, int paramInt2, int paramInt3);
+  
+  void lightColumnChanged(int paramInt1, int paramInt2, int paramInt3, int paramInt4);
+  
+  void allChanged();
+}
diff -Nru decomped/com/mojang/rubydung/level/LevelRenderer.java src/main/java/com/mojang/rubydung/level/LevelRenderer.java
--- decomped/com/mojang/rubydung/level/LevelRenderer.java	1970-01-01 03:00:00.000000000 +0300
+++ src/main/java/com/mojang/rubydung/level/LevelRenderer.java	2023-09-22 22:15:51.378027778 +0300
@@ -0,0 +1,144 @@
+package com.mojang.rubydung.level;
+
+import com.mojang.rubydung.HitResult;
+import com.mojang.rubydung.Player;
+import com.mojang.rubydung.phys.AABB;
+import org.lwjgl.opengl.GL11;
+
+public class LevelRenderer implements LevelListener {
+  private static final int CHUNK_SIZE = 16;
+  
+  private Level level;
+  
+  private Chunk[] chunks;
+  
+  private int xChunks;
+  
+  private int yChunks;
+  
+  private int zChunks;
+  
+  Tesselator t;
+  
+  public LevelRenderer(Level level) {
+    this.t = new Tesselator();
+    this.level = level;
+    level.addListener(this);
+    this.xChunks = level.width / 16;
+    this.yChunks = level.depth / 16;
+    this.zChunks = level.height / 16;
+    this.chunks = new Chunk[this.xChunks * this.yChunks * this.zChunks];
+    for (int x = 0; x < this.xChunks; x++) {
+      for (int y = 0; y < this.yChunks; y++) {
+        for (int z = 0; z < this.zChunks; z++) {
+          int x0 = x * 16;
+          int y0 = y * 16;
+          int z0 = z * 16;
+          int x1 = (x + 1) * 16;
+          int y1 = (y + 1) * 16;
+          int z1 = (z + 1) * 16;
+          if (x1 > level.width)
+            x1 = level.width; 
+          if (y1 > level.depth)
+            y1 = level.depth; 
+          if (z1 > level.height)
+            z1 = level.height; 
+          this.chunks[(x + y * this.xChunks) * this.zChunks + z] = new Chunk(level, x0, y0, z0, x1, y1, z1);
+        } 
+      } 
+    } 
+  }
+  
+  public void render(Player player, int layer) {
+    Chunk.rebuiltThisFrame = 0;
+    Frustum frustum = Frustum.getFrustum();
+    for (int i = 0; i < this.chunks.length; i++) {
+      if (frustum.cubeInFrustum((this.chunks[i]).aabb))
+        this.chunks[i].render(layer); 
+    } 
+  }
+  
+  public void pick(Player player) {
+    float r = 3.0F;
+    AABB box = player.bb.grow(r, r, r);
+    int x0 = (int)box.x0;
+    int x1 = (int)(box.x1 + 1.0F);
+    int y0 = (int)box.y0;
+    int y1 = (int)(box.y1 + 1.0F);
+    int z0 = (int)box.z0;
+    int z1 = (int)(box.z1 + 1.0F);
+    GL11.glInitNames();
+    for (int x = x0; x < x1; x++) {
+      GL11.glPushName(x);
+      for (int y = y0; y < y1; y++) {
+        GL11.glPushName(y);
+        for (int z = z0; z < z1; z++) {
+          GL11.glPushName(z);
+          if (this.level.isSolidTile(x, y, z)) {
+            GL11.glPushName(0);
+            for (int i = 0; i < 6; i++) {
+              GL11.glPushName(i);
+              this.t.init();
+              Tile.rock.renderFace(this.t, x, y, z, i);
+              this.t.flush();
+              GL11.glPopName();
+            } 
+            GL11.glPopName();
+          } 
+          GL11.glPopName();
+        } 
+        GL11.glPopName();
+      } 
+      GL11.glPopName();
+    } 
+  }
+  
+  public void renderHit(HitResult h) {
+    GL11.glEnable(3042);
+    GL11.glBlendFunc(770, 1);
+    GL11.glColor4f(1.0F, 1.0F, 1.0F, (float)Math.sin(System.currentTimeMillis() / 100.0D) * 0.2F + 0.4F);
+    this.t.init();
+    Tile.rock.renderFace(this.t, h.x, h.y, h.z, h.f);
+    this.t.flush();
+    GL11.glDisable(3042);
+  }
+  
+  public void setDirty(int x0, int y0, int z0, int x1, int y1, int z1) {
+    x0 /= 16;
+    x1 /= 16;
+    y0 /= 16;
+    y1 /= 16;
+    z0 /= 16;
+    z1 /= 16;
+    if (x0 < 0)
+      x0 = 0; 
+    if (y0 < 0)
+      y0 = 0; 
+    if (z0 < 0)
+      z0 = 0; 
+    if (x1 >= this.xChunks)
+      x1 = this.xChunks - 1; 
+    if (y1 >= this.yChunks)
+      y1 = this.yChunks - 1; 
+    if (z1 >= this.zChunks)
+      z1 = this.zChunks - 1; 
+    for (int x = x0; x <= x1; x++) {
+      for (int y = y0; y <= y1; y++) {
+        for (int z = z0; z <= z1; z++)
+          this.chunks[(x + y * this.xChunks) * this.zChunks + z].setDirty(); 
+      } 
+    } 
+  }
+  
+  public void tileChanged(int x, int y, int z) {
+    setDirty(x - 1, y - 1, z - 1, x + 1, y + 1, z + 1);
+  }
+  
+  public void lightColumnChanged(int x, int z, int y0, int y1) {
+    setDirty(x - 1, y0 - 1, z - 1, x + 1, y1 + 1, z + 1);
+  }
+  
+  public void allChanged() {
+    setDirty(0, 0, 0, this.level.width, this.level.depth, this.level.height);
+  }
+}
diff -Nru decomped/com/mojang/rubydung/level/Tesselator.java src/main/java/com/mojang/rubydung/level/Tesselator.java
--- decomped/com/mojang/rubydung/level/Tesselator.java	1970-01-01 03:00:00.000000000 +0300
+++ src/main/java/com/mojang/rubydung/level/Tesselator.java	2023-09-22 22:15:51.386027768 +0300
@@ -0,0 +1,91 @@
+package com.mojang.rubydung.level;
+
+import java.nio.FloatBuffer;
+import org.lwjgl.BufferUtils;
+import org.lwjgl.opengl.GL11;
+
+public class Tesselator {
+  private static final int MAX_VERTICES = 100000;
+  
+  private FloatBuffer vertexBuffer = BufferUtils.createFloatBuffer(300000);
+  
+  private FloatBuffer texCoordBuffer = BufferUtils.createFloatBuffer(200000);
+  
+  private FloatBuffer colorBuffer = BufferUtils.createFloatBuffer(300000);
+  
+  private int vertices = 0;
+  
+  private float u;
+  
+  private float v;
+  
+  private float r;
+  
+  private float g;
+  
+  private float b;
+  
+  private boolean hasColor = false;
+  
+  private boolean hasTexture = false;
+  
+  public void flush() {
+    this.vertexBuffer.flip();
+    this.texCoordBuffer.flip();
+    this.colorBuffer.flip();
+    GL11.glVertexPointer(3, 0, this.vertexBuffer);
+    if (this.hasTexture)
+      GL11.glTexCoordPointer(2, 0, this.texCoordBuffer); 
+    if (this.hasColor)
+      GL11.glColorPointer(3, 0, this.colorBuffer); 
+    GL11.glEnableClientState(32884);
+    if (this.hasTexture)
+      GL11.glEnableClientState(32888); 
+    if (this.hasColor)
+      GL11.glEnableClientState(32886); 
+    GL11.glDrawArrays(7, 0, this.vertices);
+    GL11.glDisableClientState(32884);
+    if (this.hasTexture)
+      GL11.glDisableClientState(32888); 
+    if (this.hasColor)
+      GL11.glDisableClientState(32886); 
+    clear();
+  }
+  
+  private void clear() {
+    this.vertices = 0;
+    this.vertexBuffer.clear();
+    this.texCoordBuffer.clear();
+    this.colorBuffer.clear();
+  }
+  
+  public void init() {
+    clear();
+    this.hasColor = false;
+    this.hasTexture = false;
+  }
+  
+  public void tex(float u, float v) {
+    this.hasTexture = true;
+    this.u = u;
+    this.v = v;
+  }
+  
+  public void color(float r, float g, float b) {
+    this.hasColor = true;
+    this.r = r;
+    this.g = g;
+    this.b = b;
+  }
+  
+  public void vertex(float x, float y, float z) {
+    this.vertexBuffer.put(this.vertices * 3 + 0, x).put(this.vertices * 3 + 1, y).put(this.vertices * 3 + 2, z);
+    if (this.hasTexture)
+      this.texCoordBuffer.put(this.vertices * 2 + 0, this.u).put(this.vertices * 2 + 1, this.v); 
+    if (this.hasColor)
+      this.colorBuffer.put(this.vertices * 3 + 0, this.r).put(this.vertices * 3 + 1, this.g).put(this.vertices * 3 + 2, this.b); 
+    this.vertices++;
+    if (this.vertices == 100000)
+      flush(); 
+  }
+}
diff -Nru decomped/com/mojang/rubydung/level/Tile.java src/main/java/com/mojang/rubydung/level/Tile.java
--- decomped/com/mojang/rubydung/level/Tile.java	1970-01-01 03:00:00.000000000 +0300
+++ src/main/java/com/mojang/rubydung/level/Tile.java	2023-09-22 22:15:51.390027764 +0300
@@ -0,0 +1,158 @@
+package com.mojang.rubydung.level;
+
+public class Tile {
+  public static Tile rock = new Tile(0);
+  
+  public static Tile grass = new Tile(1);
+  
+  private int tex = 0;
+  
+  private Tile(int tex) {
+    this.tex = tex;
+  }
+  
+  public void render(Tesselator t, Level level, int layer, int x, int y, int z) {
+    float u0 = this.tex / 16.0F;
+    float u1 = u0 + 0.0624375F;
+    float v0 = 0.0F;
+    float v1 = v0 + 0.0624375F;
+    float c1 = 1.0F;
+    float c2 = 0.8F;
+    float c3 = 0.6F;
+    float x0 = x + 0.0F;
+    float x1 = x + 1.0F;
+    float y0 = y + 0.0F;
+    float y1 = y + 1.0F;
+    float z0 = z + 0.0F;
+    float z1 = z + 1.0F;
+    if (!level.isSolidTile(x, y - 1, z)) {
+      float br = level.getBrightness(x, y - 1, z) * c1;
+      if ((((br == c1) ? 1 : 0) ^ ((layer == 1) ? 1 : 0)) != 0) {
+        t.color(br, br, br);
+        t.tex(u0, v1);
+        t.vertex(x0, y0, z1);
+        t.tex(u0, v0);
+        t.vertex(x0, y0, z0);
+        t.tex(u1, v0);
+        t.vertex(x1, y0, z0);
+        t.tex(u1, v1);
+        t.vertex(x1, y0, z1);
+      } 
+    } 
+    if (!level.isSolidTile(x, y + 1, z)) {
+      float br = level.getBrightness(x, y, z) * c1;
+      if ((((br == c1) ? 1 : 0) ^ ((layer == 1) ? 1 : 0)) != 0) {
+        t.color(br, br, br);
+        t.tex(u1, v1);
+        t.vertex(x1, y1, z1);
+        t.tex(u1, v0);
+        t.vertex(x1, y1, z0);
+        t.tex(u0, v0);
+        t.vertex(x0, y1, z0);
+        t.tex(u0, v1);
+        t.vertex(x0, y1, z1);
+      } 
+    } 
+    if (!level.isSolidTile(x, y, z - 1)) {
+      float br = level.getBrightness(x, y, z - 1) * c2;
+      if ((((br == c2) ? 1 : 0) ^ ((layer == 1) ? 1 : 0)) != 0) {
+        t.color(br, br, br);
+        t.tex(u1, v0);
+        t.vertex(x0, y1, z0);
+        t.tex(u0, v0);
+        t.vertex(x1, y1, z0);
+        t.tex(u0, v1);
+        t.vertex(x1, y0, z0);
+        t.tex(u1, v1);
+        t.vertex(x0, y0, z0);
+      } 
+    } 
+    if (!level.isSolidTile(x, y, z + 1)) {
+      float br = level.getBrightness(x, y, z + 1) * c2;
+      if ((((br == c2) ? 1 : 0) ^ ((layer == 1) ? 1 : 0)) != 0) {
+        t.color(br, br, br);
+        t.tex(u0, v0);
+        t.vertex(x0, y1, z1);
+        t.tex(u0, v1);
+        t.vertex(x0, y0, z1);
+        t.tex(u1, v1);
+        t.vertex(x1, y0, z1);
+        t.tex(u1, v0);
+        t.vertex(x1, y1, z1);
+      } 
+    } 
+    if (!level.isSolidTile(x - 1, y, z)) {
+      float br = level.getBrightness(x - 1, y, z) * c3;
+      if ((((br == c3) ? 1 : 0) ^ ((layer == 1) ? 1 : 0)) != 0) {
+        t.color(br, br, br);
+        t.tex(u1, v0);
+        t.vertex(x0, y1, z1);
+        t.tex(u0, v0);
+        t.vertex(x0, y1, z0);
+        t.tex(u0, v1);
+        t.vertex(x0, y0, z0);
+        t.tex(u1, v1);
+        t.vertex(x0, y0, z1);
+      } 
+    } 
+    if (!level.isSolidTile(x + 1, y, z)) {
+      float br = level.getBrightness(x + 1, y, z) * c3;
+      if ((((br == c3) ? 1 : 0) ^ ((layer == 1) ? 1 : 0)) != 0) {
+        t.color(br, br, br);
+        t.tex(u0, v1);
+        t.vertex(x1, y0, z1);
+        t.tex(u1, v1);
+        t.vertex(x1, y0, z0);
+        t.tex(u1, v0);
+        t.vertex(x1, y1, z0);
+        t.tex(u0, v0);
+        t.vertex(x1, y1, z1);
+      } 
+    } 
+  }
+  
+  public void renderFace(Tesselator t, int x, int y, int z, int face) {
+    float x0 = x + 0.0F;
+    float x1 = x + 1.0F;
+    float y0 = y + 0.0F;
+    float y1 = y + 1.0F;
+    float z0 = z + 0.0F;
+    float z1 = z + 1.0F;
+    if (face == 0) {
+      t.vertex(x0, y0, z1);
+      t.vertex(x0, y0, z0);
+      t.vertex(x1, y0, z0);
+      t.vertex(x1, y0, z1);
+    } 
+    if (face == 1) {
+      t.vertex(x1, y1, z1);
+      t.vertex(x1, y1, z0);
+      t.vertex(x0, y1, z0);
+      t.vertex(x0, y1, z1);
+    } 
+    if (face == 2) {
+      t.vertex(x0, y1, z0);
+      t.vertex(x1, y1, z0);
+      t.vertex(x1, y0, z0);
+      t.vertex(x0, y0, z0);
+    } 
+    if (face == 3) {
+      t.vertex(x0, y1, z1);
+      t.vertex(x0, y0, z1);
+      t.vertex(x1, y0, z1);
+      t.vertex(x1, y1, z1);
+    } 
+    if (face == 4) {
+      t.vertex(x0, y1, z1);
+      t.vertex(x0, y1, z0);
+      t.vertex(x0, y0, z0);
+      t.vertex(x0, y0, z1);
+    } 
+    if (face == 5) {
+      t.vertex(x1, y0, z1);
+      t.vertex(x1, y0, z0);
+      t.vertex(x1, y1, z0);
+      t.vertex(x1, y1, z1);
+    } 
+  }
+}
diff -Nru decomped/com/mojang/rubydung/phys/AABB.java src/main/java/com/mojang/rubydung/phys/AABB.java
--- decomped/com/mojang/rubydung/phys/AABB.java	1970-01-01 03:00:00.000000000 +0300
+++ src/main/java/com/mojang/rubydung/phys/AABB.java	2023-09-22 22:15:51.374027783 +0300
@@ -0,0 +1,131 @@
+package com.mojang.rubydung.phys;
+
+public class AABB {
+  private float epsilon = 0.0F;
+  
+  public float x0;
+  
+  public float y0;
+  
+  public float z0;
+  
+  public float x1;
+  
+  public float y1;
+  
+  public float z1;
+  
+  public AABB(float x0, float y0, float z0, float x1, float y1, float z1) {
+    this.x0 = x0;
+    this.y0 = y0;
+    this.z0 = z0;
+    this.x1 = x1;
+    this.y1 = y1;
+    this.z1 = z1;
+  }
+  
+  public AABB expand(float xa, float ya, float za) {
+    float _x0 = this.x0;
+    float _y0 = this.y0;
+    float _z0 = this.z0;
+    float _x1 = this.x1;
+    float _y1 = this.y1;
+    float _z1 = this.z1;
+    if (xa < 0.0F)
+      _x0 += xa; 
+    if (xa > 0.0F)
+      _x1 += xa; 
+    if (ya < 0.0F)
+      _y0 += ya; 
+    if (ya > 0.0F)
+      _y1 += ya; 
+    if (za < 0.0F)
+      _z0 += za; 
+    if (za > 0.0F)
+      _z1 += za; 
+    return new AABB(_x0, _y0, _z0, _x1, _y1, _z1);
+  }
+  
+  public AABB grow(float xa, float ya, float za) {
+    float _x0 = this.x0 - xa;
+    float _y0 = this.y0 - ya;
+    float _z0 = this.z0 - za;
+    float _x1 = this.x1 + xa;
+    float _y1 = this.y1 + ya;
+    float _z1 = this.z1 + za;
+    return new AABB(_x0, _y0, _z0, _x1, _y1, _z1);
+  }
+  
+  public float clipXCollide(AABB c, float xa) {
+    if (c.y1 <= this.y0 || c.y0 >= this.y1)
+      return xa; 
+    if (c.z1 <= this.z0 || c.z0 >= this.z1)
+      return xa; 
+    if (xa > 0.0F && c.x1 <= this.x0) {
+      float max = this.x0 - c.x1 - this.epsilon;
+      if (max < xa)
+        xa = max; 
+    } 
+    if (xa < 0.0F && c.x0 >= this.x1) {
+      float max = this.x1 - c.x0 + this.epsilon;
+      if (max > xa)
+        xa = max; 
+    } 
+    return xa;
+  }
+  
+  public float clipYCollide(AABB c, float ya) {
+    if (c.x1 <= this.x0 || c.x0 >= this.x1)
+      return ya; 
+    if (c.z1 <= this.z0 || c.z0 >= this.z1)
+      return ya; 
+    if (ya > 0.0F && c.y1 <= this.y0) {
+      float max = this.y0 - c.y1 - this.epsilon;
+      if (max < ya)
+        ya = max; 
+    } 
+    if (ya < 0.0F && c.y0 >= this.y1) {
+      float max = this.y1 - c.y0 + this.epsilon;
+      if (max > ya)
+        ya = max; 
+    } 
+    return ya;
+  }
+  
+  public float clipZCollide(AABB c, float za) {
+    if (c.x1 <= this.x0 || c.x0 >= this.x1)
+      return za; 
+    if (c.y1 <= this.y0 || c.y0 >= this.y1)
+      return za; 
+    if (za > 0.0F && c.z1 <= this.z0) {
+      float max = this.z0 - c.z1 - this.epsilon;
+      if (max < za)
+        za = max; 
+    } 
+    if (za < 0.0F && c.z0 >= this.z1) {
+      float max = this.z1 - c.z0 + this.epsilon;
+      if (max > za)
+        za = max; 
+    } 
+    return za;
+  }
+  
+  public boolean intersects(AABB c) {
+    if (c.x1 <= this.x0 || c.x0 >= this.x1)
+      return false; 
+    if (c.y1 <= this.y0 || c.y0 >= this.y1)
+      return false; 
+    if (c.z1 <= this.z0 || c.z0 >= this.z1)
+      return false; 
+    return true;
+  }
+  
+  public void move(float xa, float ya, float za) {
+    this.x0 += xa;
+    this.y0 += ya;
+    this.z0 += za;
+    this.x1 += xa;
+    this.y1 += ya;
+    this.z1 += za;
+  }
+}
diff -Nru decomped/com/mojang/rubydung/pissmc/Event.java src/main/java/com/mojang/rubydung/pissmc/Event.java
--- decomped/com/mojang/rubydung/pissmc/Event.java	1970-01-01 03:00:00.000000000 +0300
+++ src/main/java/com/mojang/rubydung/pissmc/Event.java	2023-09-23 21:37:42.227299923 +0300
@@ -0,0 +1,8 @@
+package com.mojang.rubydung.pissmc;
+
+public enum Event {
+    GAME_LOAD,
+    GAME_DESTROY,
+    PRE_PLAYER_TICK,
+    POST_PLAYER_TICK
+}
diff -Nru decomped/com/mojang/rubydung/pissmc/EventResult.java src/main/java/com/mojang/rubydung/pissmc/EventResult.java
--- decomped/com/mojang/rubydung/pissmc/EventResult.java	1970-01-01 03:00:00.000000000 +0300
+++ src/main/java/com/mojang/rubydung/pissmc/EventResult.java	2023-09-23 18:35:42.039283615 +0300
@@ -0,0 +1,5 @@
+package com.mojang.rubydung.pissmc;
+
+public class EventResult {
+    
+}
diff -Nru decomped/com/mojang/rubydung/pissmc/Loader.java src/main/java/com/mojang/rubydung/pissmc/Loader.java
--- decomped/com/mojang/rubydung/pissmc/Loader.java	1970-01-01 03:00:00.000000000 +0300
+++ src/main/java/com/mojang/rubydung/pissmc/Loader.java	2023-09-23 22:58:36.745363499 +0300
@@ -0,0 +1,56 @@
+package com.mojang.rubydung.pissmc;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.lang.reflect.InvocationTargetException;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.function.Consumer;
+
+import com.google.gson.Gson;
+import com.google.gson.JsonObject;
+
+public class Loader {
+    private static HashMap<Event, ArrayList<Consumer<EventResult>>> eventHandlers = new HashMap<>();
+
+    public static void create() throws ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, IOException {
+        for (Event e : Event.values()) {
+            eventHandlers.put(e, new ArrayList<>());
+        }
+        
+        File modsDir = Paths.get(System.getProperty("user.dir"), "mods").toFile();
+        if (!modsDir.exists()) modsDir.mkdir();
+
+        for (File f : modsDir.listFiles()) {
+            if (!f.getName().endsWith(".jar")) continue;
+            URLClassLoader jarLoader = new URLClassLoader(new URL[]{f.toURI().toURL()});
+
+            String mainClass;
+            try {
+                mainClass = new Gson().fromJson(new InputStreamReader(jarLoader.getResourceAsStream("META-INF/piss.json")), JsonObject.class).get("class").getAsString();
+            } catch (Exception e) {
+                System.out.println(String.format("Ignoring \"%s\" mod (broken jar)", f.getName().split(".")[0]));
+                e.printStackTrace();
+                continue;
+            }
+            
+            Class<?> modClass = jarLoader.loadClass(mainClass);
+            modClass.getConstructor().newInstance();
+            jarLoader.close();
+        }
+    }
+    public static void addEventHandler(Event e, Consumer<EventResult> handler) {
+        eventHandlers.get(e).add(handler);
+    }
+    public static EventResult triggerEvent(Event e) {
+        EventResult result = new EventResult();
+        for (Consumer<EventResult> h : eventHandlers.get(e)) {
+            h.accept(result);
+        }
+        return result;
+    }
+}
diff -Nru decomped/com/mojang/rubydung/Player.java src/main/java/com/mojang/rubydung/Player.java
--- decomped/com/mojang/rubydung/Player.java	1970-01-01 03:00:00.000000000 +0300
+++ src/main/java/com/mojang/rubydung/Player.java	2023-09-22 23:51:40.293621506 +0300
@@ -0,0 +1,141 @@
+package com.mojang.rubydung;
+
+import com.mojang.rubydung.level.Level;
+import com.mojang.rubydung.phys.AABB;
+import java.util.List;
+import org.lwjgl.input.Keyboard;
+
+public class Player {
+  private Level level;
+  
+  public float xo;
+  
+  public float yo;
+  
+  public float zo;
+  
+  public float x;
+  
+  public float y;
+  
+  public float z;
+  
+  public float xd;
+  
+  public float yd;
+  
+  public float zd;
+
+  public float xa;
+
+  public float ya;
+  
+  public float yRot;
+  
+  public float xRot;
+  
+  public AABB bb;
+  
+  public boolean onGround = false;
+  
+  public Player(Level level) {
+    this.level = level;
+    resetPos();
+  }
+  
+  private void resetPos() {
+    float x = (float)Math.random() * this.level.width;
+    float y = (this.level.depth + 10);
+    float z = (float)Math.random() * this.level.height;
+    setPos(x, y, z);
+  }
+  
+  private void setPos(float x, float y, float z) {
+    this.x = x;
+    this.y = y;
+    this.z = z;
+    float w = 0.3F;
+    float h = 0.9F;
+    this.bb = new AABB(x - w, y - h, z - w, x + w, y + h, z + w);
+  }
+  
+  public void turn(float xo, float yo) {
+    this.yRot = (float)(this.yRot + xo * 0.15D);
+    this.xRot = (float)(this.xRot - yo * 0.15D);
+    if (this.xRot < -90.0F)
+      this.xRot = -90.0F; 
+    if (this.xRot > 90.0F)
+      this.xRot = 90.0F; 
+  }
+  
+  public void tick() {
+    this.xo = this.x;
+    this.yo = this.y;
+    this.zo = this.z;
+    this.xa = 0.0F;
+    this.ya = 0.0F;
+    if (Keyboard.isKeyDown(19))
+      resetPos(); 
+    if (Keyboard.isKeyDown(200) || Keyboard.isKeyDown(17))
+      ya--; 
+    if (Keyboard.isKeyDown(208) || Keyboard.isKeyDown(31))
+      ya++; 
+    if (Keyboard.isKeyDown(203) || Keyboard.isKeyDown(30))
+      xa--; 
+    if (Keyboard.isKeyDown(205) || Keyboard.isKeyDown(32))
+      xa++; 
+    if (Keyboard.isKeyDown(57) || Keyboard.isKeyDown(219))
+      if (this.onGround)
+        this.yd = 0.12F;  
+    moveRelative(xa, ya, this.onGround ? 0.02F : 0.005F);
+    this.yd = (float)(this.yd - 0.005D);
+    move(this.xd, this.yd, this.zd);
+    this.xd *= 0.91F;
+    this.yd *= 0.98F;
+    this.zd *= 0.91F;
+    if (this.onGround) {
+      this.xd *= 0.8F;
+      this.zd *= 0.8F;
+    } 
+  }
+  
+  public void move(float xa, float ya, float za) {
+    float xaOrg = xa;
+    float yaOrg = ya;
+    float zaOrg = za;
+    List<AABB> aABBs = this.level.getCubes(this.bb.expand(xa, ya, za));
+    int i;
+    for (i = 0; i < aABBs.size(); i++)
+      ya = ((AABB)aABBs.get(i)).clipYCollide(this.bb, ya); 
+    this.bb.move(0.0F, ya, 0.0F);
+    for (i = 0; i < aABBs.size(); i++)
+      xa = ((AABB)aABBs.get(i)).clipXCollide(this.bb, xa); 
+    this.bb.move(xa, 0.0F, 0.0F);
+    for (i = 0; i < aABBs.size(); i++)
+      za = ((AABB)aABBs.get(i)).clipZCollide(this.bb, za); 
+    this.bb.move(0.0F, 0.0F, za);
+    this.onGround = (yaOrg != ya && yaOrg < 0.0F);
+    if (xaOrg != xa)
+      this.xd = 0.0F; 
+    if (yaOrg != ya)
+      this.yd = 0.0F; 
+    if (zaOrg != za)
+      this.zd = 0.0F; 
+    this.x = (this.bb.x0 + this.bb.x1) / 2.0F;
+    this.y = this.bb.y0 + 1.62F;
+    this.z = (this.bb.z0 + this.bb.z1) / 2.0F;
+  }
+  
+  public void moveRelative(float xa, float za, float speed) {
+    float dist = xa * xa + za * za;
+    if (dist < 0.01F)
+      return; 
+    dist = speed / (float)Math.sqrt(dist);
+    xa *= dist;
+    za *= dist;
+    float sin = (float)Math.sin(this.yRot * Math.PI / 180.0D);
+    float cos = (float)Math.cos(this.yRot * Math.PI / 180.0D);
+    this.xd += xa * cos - za * sin;
+    this.zd += za * cos + xa * sin;
+  }
+}
diff -Nru decomped/com/mojang/rubydung/RubyDung.java src/main/java/com/mojang/rubydung/RubyDung.java
--- decomped/com/mojang/rubydung/RubyDung.java	1970-01-01 03:00:00.000000000 +0300
+++ src/main/java/com/mojang/rubydung/RubyDung.java	2023-09-23 23:01:26.165131251 +0300
@@ -0,0 +1,258 @@
+package com.mojang.rubydung;
+
+import com.mojang.rubydung.level.Chunk;
+import com.mojang.rubydung.level.Level;
+import com.mojang.rubydung.level.LevelRenderer;
+import com.mojang.rubydung.pissmc.Event;
+import com.mojang.rubydung.pissmc.Loader;
+
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
+import javax.swing.JOptionPane;
+import org.lwjgl.BufferUtils;
+import org.lwjgl.LWJGLException;
+import org.lwjgl.input.Keyboard;
+import org.lwjgl.input.Mouse;
+import org.lwjgl.opengl.Display;
+import org.lwjgl.opengl.DisplayMode;
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.util.glu.GLU;
+
+public class RubyDung implements Runnable {
+  private static final boolean FULLSCREEN_MODE = false;
+  private static RubyDung instance;
+  
+  private int width;
+  
+  private int height;
+  
+  private FloatBuffer fogColor = BufferUtils.createFloatBuffer(4);
+  
+  private Timer timer = new Timer(60.0F);
+  
+  private Level level;
+  
+  private LevelRenderer levelRenderer;
+  
+  private Player player;
+
+  public int col = 920330;
+  public float fr = 0.5F;
+  public float fg = 0.8F;
+  public float fb = 1.0F;
+  
+  public void init() throws LWJGLException, IOException, ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
+    instance = this;
+    Loader.create();
+    this.fogColor.put(new float[] { (col >> 16 & 0xFF) / 255.0F, (col >> 8 & 0xFF) / 255.0F, (col & 0xFF) / 255.0F, 1.0F });
+    this.fogColor.flip();
+    Display.setDisplayMode(new DisplayMode(1024, 768));
+    Display.setTitle("Minecraft rd-132211 (PissMC powered)");
+    Display.create();
+    Keyboard.create();
+    Mouse.create();
+    this.width = Display.getDisplayMode().getWidth();
+    this.height = Display.getDisplayMode().getHeight();
+    GL11.glEnable(3553);
+    GL11.glShadeModel(7425);
+    GL11.glClearColor(fr, fg, fb, 0.0F);
+    GL11.glClearDepth(1.0D);
+    GL11.glEnable(2929);
+    GL11.glDepthFunc(515);
+    GL11.glMatrixMode(5889);
+    GL11.glLoadIdentity();
+    GL11.glMatrixMode(5888);
+    this.level = new Level(256, 256, 64);
+    this.levelRenderer = new LevelRenderer(this.level);
+    this.player = new Player(this.level);
+    Mouse.setGrabbed(true);
+    Loader.triggerEvent(Event.GAME_LOAD);
+  }
+  
+  public void destroy() {
+    this.level.save();
+    Mouse.destroy();
+    Keyboard.destroy();
+    Display.destroy();
+    Loader.triggerEvent(Event.GAME_DESTROY);
+  }
+  
+  public void run() {
+    try {
+      init();
+    } catch (Exception e) {
+      JOptionPane.showMessageDialog(null, e.toString(), "Failed to start RubyDung", 0);
+      System.exit(0);
+    } 
+    long lastTime = System.currentTimeMillis();
+    int frames = 0;
+    try {
+      while (!Keyboard.isKeyDown(1) && !Display.isCloseRequested()) {
+        this.timer.advanceTime();
+        for (int i = 0; i < this.timer.ticks; i++)
+          tick(); 
+        render(this.timer.a);
+        frames++;
+        while (System.currentTimeMillis() >= lastTime + 1000L) {
+          System.out.println(String.valueOf(frames) + " fps, " + Chunk.updates);
+          Chunk.updates = 0;
+          lastTime += 1000L;
+          frames = 0;
+        } 
+      } 
+    } catch (Exception e) {
+      e.printStackTrace();
+    } finally {
+      destroy();
+    } 
+  }
+  
+  public void tick() {
+    Loader.triggerEvent(Event.PRE_PLAYER_TICK);
+    this.player.tick();
+    Loader.triggerEvent(Event.POST_PLAYER_TICK);
+  }
+  
+  private void moveCameraToPlayer(float a) {
+    GL11.glTranslatef(0.0F, 0.0F, -0.3F);
+    GL11.glRotatef(this.player.xRot, 1.0F, 0.0F, 0.0F);
+    GL11.glRotatef(this.player.yRot, 0.0F, 1.0F, 0.0F);
+    float x = this.player.xo + (this.player.x - this.player.xo) * a;
+    float y = this.player.yo + (this.player.y - this.player.yo) * a;
+    float z = this.player.zo + (this.player.z - this.player.zo) * a;
+    GL11.glTranslatef(-x, -y, -z);
+  }
+  
+  private void setupCamera(float a) {
+    GL11.glMatrixMode(5889);
+    GL11.glLoadIdentity();
+    GLU.gluPerspective(70.0F, this.width / this.height, 0.05F, 1000.0F);
+    GL11.glMatrixMode(5888);
+    GL11.glLoadIdentity();
+    moveCameraToPlayer(a);
+  }
+  
+  private IntBuffer viewportBuffer = BufferUtils.createIntBuffer(16);
+  
+  private void setupPickCamera(float a, int x, int y) {
+    GL11.glMatrixMode(5889);
+    GL11.glLoadIdentity();
+    this.viewportBuffer.clear();
+    GL11.glGetInteger(2978, this.viewportBuffer);
+    this.viewportBuffer.flip();
+    this.viewportBuffer.limit(16);
+    GLU.gluPickMatrix(x, y, 5.0F, 5.0F, this.viewportBuffer);
+    GLU.gluPerspective(70.0F, this.width / this.height, 0.05F, 1000.0F);
+    GL11.glMatrixMode(5888);
+    GL11.glLoadIdentity();
+    moveCameraToPlayer(a);
+  }
+  
+  private IntBuffer selectBuffer = BufferUtils.createIntBuffer(2000);
+  
+  private HitResult hitResult = null;
+  
+  private void pick(float a) {
+    this.selectBuffer.clear();
+    GL11.glSelectBuffer(this.selectBuffer);
+    GL11.glRenderMode(7170);
+    setupPickCamera(a, this.width / 2, this.height / 2);
+    this.levelRenderer.pick(this.player);
+    int hits = GL11.glRenderMode(7168);
+    this.selectBuffer.flip();
+    this.selectBuffer.limit(this.selectBuffer.capacity());
+    long closest = 0L;
+    int[] names = new int[10];
+    int hitNameCount = 0;
+    for (int i = 0; i < hits; i++) {
+      int nameCount = this.selectBuffer.get();
+      long minZ = this.selectBuffer.get();
+      this.selectBuffer.get();
+      long dist = minZ;
+      if (dist < closest || i == 0) {
+        closest = dist;
+        hitNameCount = nameCount;
+        for (int j = 0; j < nameCount; j++)
+          names[j] = this.selectBuffer.get(); 
+      } else {
+        for (int j = 0; j < nameCount; j++)
+          this.selectBuffer.get(); 
+      } 
+    } 
+    if (hitNameCount > 0) {
+      this.hitResult = new HitResult(names[0], names[1], names[2], names[3], names[4]);
+    } else {
+      this.hitResult = null;
+    } 
+  }
+  
+  public void render(float a) {
+    float xo = Mouse.getDX();
+    float yo = Mouse.getDY();
+    this.player.turn(xo, yo);
+    pick(a);
+    while (Mouse.next()) {
+      if (Mouse.getEventButton() == 1 && Mouse.getEventButtonState())
+        if (this.hitResult != null)
+          this.level.setTile(this.hitResult.x, this.hitResult.y, this.hitResult.z, 0);  
+      if (Mouse.getEventButton() == 0 && Mouse.getEventButtonState())
+        if (this.hitResult != null) {
+          int x = this.hitResult.x;
+          int y = this.hitResult.y;
+          int z = this.hitResult.z;
+          if (this.hitResult.f == 0)
+            y--; 
+          if (this.hitResult.f == 1)
+            y++; 
+          if (this.hitResult.f == 2)
+            z--; 
+          if (this.hitResult.f == 3)
+            z++; 
+          if (this.hitResult.f == 4)
+            x--; 
+          if (this.hitResult.f == 5)
+            x++; 
+          this.level.setTile(x, y, z, 1);
+        }  
+    } 
+    while (Keyboard.next()) {
+      if (Keyboard.getEventKey() == 28 && Keyboard.getEventKeyState())
+        this.level.save(); 
+    } 
+    GL11.glClear(16640);
+    setupCamera(a);
+    GL11.glEnable(2884);
+    GL11.glEnable(2912);
+    GL11.glFogi(2917, 2048);
+    GL11.glFogf(2914, 0.2F);
+    GL11.glFog(2918, this.fogColor);
+    GL11.glDisable(2912);
+    this.levelRenderer.render(this.player, 0);
+    GL11.glEnable(2912);
+    this.levelRenderer.render(this.player, 1);
+    GL11.glDisable(3553);
+    if (this.hitResult != null)
+      this.levelRenderer.renderHit(this.hitResult); 
+    GL11.glDisable(2912);
+    Display.update();
+  }
+  
+  public static void checkError() {
+    int e = GL11.glGetError();
+    if (e != 0)
+      throw new IllegalStateException(GLU.gluErrorString(e)); 
+  }
+  
+  public static void main(String[] args) throws LWJGLException {
+    (new Thread(new RubyDung())).start();
+  }
+
+  public static RubyDung getInstance() {
+    return instance;
+  }
+  public Player getPlayer() {
+    return player;
+  }
+}
diff -Nru decomped/com/mojang/rubydung/Textures.java src/main/java/com/mojang/rubydung/Textures.java
--- decomped/com/mojang/rubydung/Textures.java	1970-01-01 03:00:00.000000000 +0300
+++ src/main/java/com/mojang/rubydung/Textures.java	2023-09-22 22:15:51.382027773 +0300
@@ -0,0 +1,55 @@
+package com.mojang.rubydung;
+
+import java.awt.image.BufferedImage;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
+import java.util.HashMap;
+import javax.imageio.ImageIO;
+import org.lwjgl.BufferUtils;
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.util.glu.GLU;
+
+public class Textures {
+  private static HashMap<String, Integer> idMap = new HashMap<String, Integer>();
+  
+  private static int lastId = -9999999;
+  
+  public static int loadTexture(String resourceName, int mode) {
+    try {
+      if (idMap.containsKey(resourceName))
+        return ((Integer)idMap.get(resourceName)).intValue(); 
+      IntBuffer ib = BufferUtils.createIntBuffer(1);
+      GL11.glGenTextures(ib);
+      int id = ib.get(0);
+      bind(id);
+      GL11.glTexParameteri(3553, 10241, mode);
+      GL11.glTexParameteri(3553, 10240, mode);
+      BufferedImage img = ImageIO.read(Textures.class.getResourceAsStream(resourceName));
+      int w = img.getWidth();
+      int h = img.getHeight();
+      ByteBuffer pixels = BufferUtils.createByteBuffer(w * h * 4);
+      int[] rawPixels = new int[w * h];
+      img.getRGB(0, 0, w, h, rawPixels, 0, w);
+      for (int i = 0; i < rawPixels.length; i++) {
+        int a = rawPixels[i] >> 24 & 0xFF;
+        int r = rawPixels[i] >> 16 & 0xFF;
+        int g = rawPixels[i] >> 8 & 0xFF;
+        int b = rawPixels[i] & 0xFF;
+        rawPixels[i] = a << 24 | b << 16 | g << 8 | r;
+      } 
+      pixels.asIntBuffer().put(rawPixels);
+      GLU.gluBuild2DMipmaps(3553, 6408, w, h, 6408, 5121, pixels);
+      return id;
+    } catch (IOException e) {
+      throw new RuntimeException("!!");
+    } 
+  }
+  
+  public static void bind(int id) {
+    if (id != lastId) {
+      GL11.glBindTexture(3553, id);
+      lastId = id;
+    } 
+  }
+}
diff -Nru decomped/com/mojang/rubydung/Timer.java src/main/java/com/mojang/rubydung/Timer.java
--- decomped/com/mojang/rubydung/Timer.java	1970-01-01 03:00:00.000000000 +0300
+++ src/main/java/com/mojang/rubydung/Timer.java	2023-09-22 22:15:51.386027768 +0300
@@ -0,0 +1,45 @@
+package com.mojang.rubydung;
+
+public class Timer {
+  private static final long NS_PER_SECOND = 1000000000L;
+  
+  private static final long MAX_NS_PER_UPDATE = 1000000000L;
+  
+  private static final int MAX_TICKS_PER_UPDATE = 100;
+  
+  private float ticksPerSecond;
+  
+  private long lastTime;
+  
+  public int ticks;
+  
+  public float a;
+  
+  public float timeScale = 1.0F;
+  
+  public float fps = 0.0F;
+  
+  public float passedTime = 0.0F;
+  
+  public Timer(float ticksPerSecond) {
+    this.ticksPerSecond = ticksPerSecond;
+    this.lastTime = System.nanoTime();
+  }
+  
+  public void advanceTime() {
+    long now = System.nanoTime();
+    long passedNs = now - this.lastTime;
+    this.lastTime = now;
+    if (passedNs < 0L)
+      passedNs = 0L; 
+    if (passedNs > 1000000000L)
+      passedNs = 1000000000L; 
+    this.fps = (float)(1000000000L / passedNs);
+    this.passedTime += (float)passedNs * this.timeScale * this.ticksPerSecond / 1.0E9F;
+    this.ticks = (int)this.passedTime;
+    if (this.ticks > 100)
+      this.ticks = 100; 
+    this.passedTime -= this.ticks;
+    this.a = this.passedTime;
+  }
+}
